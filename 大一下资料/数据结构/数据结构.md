# 数据结构
```c  
#include<stdio.h>
int main(){
    printf("hello");
    return 0;
}
```
## realloc function
```c
pNew = realloc(pOld, newSize);
```
## 有序表合成算法(自写)
## 单链表结构的构造
```c
LinkList* construct(){
    LinkList* pList = (LinkList*)malloc(sizeof(LinkList));
    if(pList == NULL){
        return 1;
    }
    *pList = NULL;//pList指向对象进行初始化。
    return pList;
}
```
## 通用链表
```c
/*第一种定义*/
typedef struct Node{
    void* pData;
    struct Node *pNext;
}Node, *LinkedList;

Destruct(Status (*freeData)());//析构需要知道数据的大小。
/*第二种定义*/
typedef struct ListNode ListNode;
struct ListNode{
    void* pData;
    ListNode* pNext;
};
typedef struct{
    ListNode *pFirst;
    int sizeOfData;
    int length;
}LinkedList;
```
### 创建节点
```c
ListNode* makeNode(void* pData, int dataSize){
    ListNode* pNode;
    pNode =(ListNode*)malloc(sizeof(ListNode));
    if(pNode == NULL){
        return NULL;
    }
    pNode->pData = (void*)malloc(dataSize);
    if(pNode->pData == NULL){
        return NULL;
    }
    memcpy(pNode->pNode,pData,dataSize);
    pNode->pNext = NULL;
    return pNode;
}
```
### 释放节点
```c
Status freeNode(ListNode* pNode){
    free(pNode->pData);
    free(pNode);
    return OK;
}
```
### 链表的构造
```c
LinkedList* construct(int sizeOfData){
    Linkedlist* pList;
    pList = (LinkedList*)malloc(sizeof(sizeOfData));
    if(pList == NULL){
        return NULL;
    }
    pList->pFirst = NULL;
    pList->sizeOfData = sizeOfData;
    pList->length = 0;
    return pList;
}
```
### 链表的析构
```c
void Destruct(LinkedList* pList){
    ListNode* pNode = pList->pFirst; // 从链表的头节点开始
    ListNode* pTemp = NULL;
    while (pNode != NULL) {
        pTemp = pNode;               // 保存当前节点
        pNode = pNode->pNext;        // 移动到下一个节点
        // 如果提供了释放数据的函数，则使用它来释放pData指向的数据
        if (freeData != NULL) {
            freeData(pTemp->pData);
        }
        // 释放当前节点
        free(pTemp);
    }
    // 清空链表结构中的指针和长度信息
    pList->pFirst = NULL;
    pList->length = 0;
}
// 假设这是一个用于释放pData指向数据的函数
void freeDataExample(void* pData) {
    free(pData); // 假设pData指向的是通过malloc分配的内存
}
```
### 链表的插入
```c
Status insertNode(void* pData,LinkedList* pList){
    ListNode* pNewNode = makeNode(void* pData);
    if(pNewNode == NULL){
        return ERROR;
    }
    ListNode* pTemp = pList->pFirst;
    pList->pFirst = pNewNode;
    pTemp->pFirst = pList->pFirst;
    return OK;
}
```
### 链表的遍历
```c
Status Travels(List* pList,Status(*visit)()){
    Node* pNode;
    pNode = pList->pFirst;
    while(pNode != NULL){
        visit(pNode->pData);
        if(visit(pNode->pData) == ERROR){
            return ERROR;
        }
        pNode = pNode->pNext;
    }
    return OK;
}
```
## 栈和队列
### 栈
#### 栈的定义
```c
typedef struct{
    StackElem a[N];
    int length;
    int size;
}Stack;
```
通用栈
```c
typedef struct{
    StackElem *pBase;
    StackElem *pTop;
    int size;
}Stack;
```
泛型栈
```c
typedef struct{
    void* pBase;
    void* pTop;
    int elemSize;
    int stackInitSize;
}Stack;
```
#### 栈的构造
```c
Stack* Construct(int elemSize,int stackInitSize){
    Stack* pStack;
    pStack = (Stack*)malloc(sizeof(Stack));
    if(pStack == NULL){
        return NULL;
    }
    pStack->pBase = malloc(elemSize*stackInitSize);
    if(pStack->pBase == NULL){
        free(pStack);
        return NULL;
    }
    pStack->pTop = pStack->pBase;
    return pStack;
}
```
#### 栈的析构
```c
void Destruct(Stack* pStack){
    if (stack != NULL && stack->pBase != NULL) {
        free(stack->pBase);  // 释放栈底指针指向的内存
        stack->pBase = NULL;  // 确保栈底指针为NULL，避免悬空指针
    }
    free(stack);  // 释放栈结构体的内存
    return;
}
```
#### 栈的长度
```c
int Length(const Stack* pStack){
    int length = 0;
    length = (char*)pStack->pTop - (char*)pStack->pBase;
    length /= pStack->elemSize;
    return length;
}
```
#### 栈的Push
```c
Status Push(void* pElem,Stack* pStack){
    if(length(pStack) >= size){
        int newSize = pStack->stackInitSize + EXTRA_SIZE;
        Stack* pNewStack;
        pNewStack = realloc(pStack->pBase,newSize*(pStack->elemSize));
        if(pNewStack == NULL){
            return NULL;
        }
        pStack->pBase = pNewStack;
        pStack->pTop = (char*)pStack->pBase + (pStack->stackInitSize) * (pStack->elemSize);
        pStack->stackInitSize = newSize;
    }
    pStack->pTop = memcpy(pTop,pElem,pStack->elemSize);
    pStack->pTop = (char*)(pStack->pTop) + pStack->elemSize;
    return OK;
}
```
#### 栈的Pop
```c
Status Pop(Stack* pStack){
    pStack->pTop = pStack->pTop
}
```
### 队列
#### 队列的实现
```c
typedef struct {
    QueueElem elemArray[QUEUE_SIZE];
    int front;
    int rear;
} Queue;
```
#### 队列的构造函数
```c
Queue* Construct(){
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    if(queue == NULL){
        return NULL;
    }
    queue -> front = 0;
    queue -> rear = 0;
    return queue;
}
```
#### 队列的析构函数
```c
void Destruct(Queue* queue){
    free(queue);
    return;
}
```
#### 队列的初始化
```c
void Init(Queue* queue){
    queue -> front = 0;
    queue -> rear = 0;
    return;
}
```
#### 队列的长度计算
```c
int Length(Queue* queue){
    int length = (rear - front + QUEUE_SIZE) % QUEUE_SIZE；
    return length;
}
```
#### 队列是否为空
```c
int IsEmpty(Queue* queue){
    return queue -> front == queue -> rear;
}
```
#### 队列是否为满
```c
int IsFull(Queue* queue){
    return queue -> front == (queue -> rear + 1) % QUEUE_SIZE;
}
```
#### 入队
```c
Status Enter(Queue* queue, QueueElem* pData){
    if(IsFull(queue)){
        return ERROR;
    }
    queue -> elemArray[queue -> rear] = *pData;
    queue -> rear = (queue -> rear + 1) % QUEUE_SIZE;
    return OK;
}
```
#### 出队
```c
Status Leave(Queue* queue,QueueElem* pElem){
    if(IsEmpty(queue)){
        return ERROR;
    }
    *pElem = queue -> elemArray[queue -> front];
    queue -> front = (queue -> front + 1) % QUEUE_SIZE;
    return OK;
}
```
#### 队列的遍历
```c
Status Traverse(Queue* queue,Status (*visit)()){
    int current = queue -> front;
    while(current != queue -> rear){
        if(visit(&(queue -> elemArray[current])) == ERROR){
            return ERROR;
        }
        current = (current + 1) % QUEUE_SIZE;
    }
    return OK;
}
```
### 用链表来实现队列
```c
typedef List Queue;
```
#### 构造函数
```c
Queue* QueueConstruct(){
    return ListConstruct();
}
```
#### 析构函数
```c
void QueueDestruct(Queue* queue){
    return ListConstruct(queue);
}
```
#### 长度
```c
Bool 
```
#### 入列
Status QueueEnter(Queue* queue,QueueElem* pElem){
    return ListAppend(queue,pElem);
}